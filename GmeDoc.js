/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Wed Nov 04 2015 00:40:10 GMT-0600 (CST).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'common/util/ejs',
    'plugin/GmeDoc/GmeDoc/Templates/Templates'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    TEMPLATES) {
    'use strict';

    /**
     * Initializes a new instance of GmeDoc.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin GmeDoc.
     * @constructor
     */
    var GmeDoc = function () {
        // Call base class' constructor.
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    GmeDoc.prototype = Object.create(PluginBase.prototype);
    GmeDoc.prototype.constructor = GmeDoc;

    /**
     * Gets the name of the GmeDoc.
     * @returns {string} The name of the plugin.
     * @public
     */
    GmeDoc.prototype.getName = function () {
        return 'New Doc Generator';
    };

    /**
     * Gets the semantic version (semver.org) of the GmeDoc.
     * @returns {string} The version of the plugin.
     * @public
     */
    GmeDoc.prototype.getVersion = function () {
        return '0.1.0';
    };

 GmeDoc.prototype.getConfigStructure = function () {
        return [
            {
                name: 'DocTypeName',
                displayName: 'Documentation model type',
                description: 'Please specify the meta model type name of the Documentation node.',
                value: 'Documentation',
                valueType: 'string',
                readOnly: false
            }
        ];
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    GmeDoc.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.

        //TODO: special characters.
        //TODO: parents information ;

        var self = this,
            nodeObject;
        self.currentConfig = self.getCurrentConfig();
        self.currentConfig.DocTypeName
        if(self.META[self.currentConfig.DocTypeName]==null)
        {
            self.logger.error('could not identify the meta model you specified, please re-enter the meta model type name');
            return;
        }
        // Using the logger.
        self.logger.debug('This is a debug message.');
        self.logger.info('This is an info message.');
        self.logger.warn('This is a warning message.');
        self.logger.error('This is an error message.');

        // Using the coreAPI to make changes.
        nodeObject = self.activeNode;
        var specialChar='&$%#_'
        var RootFCO;
        var rootFolder=self.rootNode;
        self.core.loadSubTree(rootFolder, function (err, nodeList) {
            if(err) {
                callback(err);
                return;
            }
            var i,
                nodePath,
                nodes = {};
            for (i=0; i<nodeList.length; i+=1) {
                nodePath = self.core.getPath(nodeList[i]);
                nodes[nodePath] = nodeList[i];
                self.logger.info(nodePath);
            }
            var nodeLevelRoot={
                node:rootFolder,
                level:0
            };
            var docMetaPath=self.core.getPath(self.META[self.currentConfig.DocTypeName]);

            var LatexStart='\\documentclass{article}\n\\usepackage[T1]{fontenc}\n\\begin{document}\n'
            var LatexEnd;
            LatexEnd='\\end{document}';
            function regReplace(originString) {
              var boldreg = /\*\*(\w+)\*\*/;
              var italicReg=/\*(\w+)\*/;
              var headReg=/^#/;
              var headReg2=/^##/;
              var newstr='';
              if(boldreg.test(originString))
              {
                originString = originString.replace(boldreg, '\\textbf{$1}');
              }
              if(italicReg.test(originString))
              {
                originString = originString.replace(italicReg, '\\textit{$1}');
              }
              if(headReg2.test(originString))
              {
                originString = originString.replace(headReg2, '\\subsection*{');
                originString+='}';
              }
              else if(headReg.test(originString))
              {
                originString = originString.replace(headReg, '\\section*{');
                originString+='}';
              }
              for (var k =0; k<originString.length; k++) {
                if(specialChar.indexOf(originString[k])!=-1) {
                  newstr+='\\'+originString[k];
                }
                else {
                  newstr+=originString[k];
                }
              }
              return newstr;
            }
            function lineSplit(originString) {
              var linebrReg=/\<br\>/;
              var resultString='';
              var boldreg = /\*\*(\w+)\*\*/;
              var stringArray=[];
              if(linebrReg.test(originString))
              {
                stringArray=originString.split(linebrReg);
              }
              else
              {
                stringArray[0]=originString;
              }
              for( var k=0; k<stringArray.length; k++)
              {
                resultString+=regReplace(stringArray[k]);
                if(resultString.charAt(resultString.length-1)!='}'&&k<stringArray.length-1)
                {
                  resultString+='\n\n';
                }
              }
              return resultString; 
            }
            function lamda(currentNode, level) {
              var childrenPaths = self.core.getChildrenPaths(currentNode); 
              var tempDoc=''; 
              var containDoc=false;
              var subChild=[];
              for (var j = 0; j<childrenPaths.length; j++) {
                  var childNode=nodes[childrenPaths[j]];
                  if (self.isMetaTypeOf(childNode, self.META[self.currentConfig.DocTypeName])
                    &&docMetaPath!=self.core.getPath(childNode)) {
                        var docAtt=self.core.getAttributeNames(childNode)
                        var docString='';
                        if(!containDoc) {
                          if(level<2) {
                            tempDoc+='\\begin{enumerate}\n';
                          }
                          else {
                            tempDoc+='\\begin{itemize}\n';
                          }
                          containDoc=true;
                        }
                        for(var k=0; k<docAtt.length; k++)
                        {   if(docAtt[k]!='name') {
                              var originString=self.core.getAttribute(childNode, docAtt[k]);
                              docString+=lineSplit(originString);

                            }
                        }
                        self.logger.error(docString);
                        tempDoc+='\\item '+self.core.getAttribute(currentNode, 'name')+'\n\n'+docString+'\n';
                  }
                  else {
                      subChild.push(childNode);
                  }
                 }
                 for(var j=0; j<subChild.length; j++) {
                    tempDoc+=lamda(subChild[j], level+1);
                 }
                if(containDoc) {
                        if(level<2) {
                          tempDoc+='\\end{enumerate}\n';
                        }
                        else {
                          tempDoc+='\\end{itemize}\n';
                        }
                   containDoc=false;
                }
              return tempDoc;
            }
            LatexStart+=lamda(rootFolder, 0);
            LatexStart=LatexStart.replace(/\n\n(\w)/g, '\\\\$1');
            LatexStart=LatexStart.replace(/\n\n(\W)/g, '$1');
            var dataStr = LatexStart+LatexEnd;
            self.logger.info(dataStr);
            //self.result.setSuccess(true);
            var artifact = self.blobClient.createArtifact('statemachine');
            artifact.addFile('model.tex', dataStr, function (err) {
                if(err) {
                    callback(err);
                    return
                }
                artifact.save(function (err, hash) {
                  if (err) {
                      callback(err);
                      return
                  }
                self.result.addArtifact(hash);

                self.result.setSuccess(true);
                callback(null, self.result);
              });
          });
            //callback(null, self.result);
        });
        return;


        // First transform ejs-files into js files (needed for client-side runs) -> run Templates/combine_templates.js.
        // See instructions in file. You must run this after any modifications to the ejs template.
        var templatePY = ejs.render(TEMPLATES['Python.py.ejs'], {a: 'a', b: 'b'});
        var templateFileName = 'generatedFiles/subDir/Python.py';
        var artifact = self.blobClient.createArtifact('templateFiles');
        artifact.addFile(templateFileName, templatePY, function (err) {
            if (err) {
                callback(err, self.result);
                return;
            }
            self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
                    callback(err, self.result);
                    return;
                }
                // This will add a download hyperlink in the result-dialog.
                self.result.addArtifact(hashes[0]);
                // This will save the changes. If you don't want to save;
                // exclude self.save and call callback directly from this scope.
                self.save('New Doc Generator updated model.', function (err) {
                    if (err) {
                        callback(err, self.result);
                        return;
                    }
                    self.result.setSuccess(true);
                    callback(null, self.result);
                });
            });
        });

    };

    return GmeDoc;
});